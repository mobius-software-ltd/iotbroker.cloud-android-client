package com.mobius.software.android.iotbroker.main.dal;

import java.util.List;
import com.mobius.software.android.iotbroker.main.dal.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table "ACCOUNTS".
 */
public class Accounts {

    private Long id;
    private Integer protocolType;
    private String userName;
    private String password;
    private String clientID;
    private String serverHost;
    private Integer port;
    private Boolean cleanSession;
    private Integer keepAlive;
    private String will;
    private String willTopic;
    private Integer qos;
    private Boolean isDefault;
    private Boolean isRetain;
    private Boolean isSecureConnection;
    private String certificatePath;
    private String certificatePassword;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient AccountsDao myDao;

    private List<Topics> topics;
    private List<Messages> messageAccount;

    public Accounts() {
    }

    public Accounts(Long id) {
        this.id = id;
    }

    public Accounts(Long id, Integer protocolType, String userName, String password, String clientID, String serverHost, Integer port, Boolean cleanSession, Integer keepAlive, String will, String willTopic, Integer qos, Boolean isDefault, Boolean isRetain, Boolean isSecureConnection, String certificatePath, String certificatePassword) {
        this.id = id;
        this.protocolType = protocolType;
        this.userName = userName;
        this.password = password;
        this.clientID = clientID;
        this.serverHost = serverHost;
        this.port = port;
        this.cleanSession = cleanSession;
        this.keepAlive = keepAlive;
        this.will = will;
        this.willTopic = willTopic;
        this.qos = qos;
        this.isDefault = isDefault;
        this.isRetain = isRetain;
        this.isSecureConnection = isSecureConnection;
        this.certificatePath = certificatePath;
        this.certificatePassword = certificatePassword;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getAccountsDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Integer getProtocolType() {
        return protocolType;
    }

    public void setProtocolType(Integer protocolType) {
        this.protocolType = protocolType;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getClientID() {
        return clientID;
    }

    public void setClientID(String clientID) {
        this.clientID = clientID;
    }

    public String getServerHost() {
        return serverHost;
    }

    public void setServerHost(String serverHost) {
        this.serverHost = serverHost;
    }

    public Integer getPort() {
        return port;
    }

    public void setPort(Integer port) {
        this.port = port;
    }

    public Boolean getCleanSession() {
        return cleanSession;
    }

    public void setCleanSession(Boolean cleanSession) {
        this.cleanSession = cleanSession;
    }

    public Integer getKeepAlive() {
        return keepAlive;
    }

    public void setKeepAlive(Integer keepAlive) {
        this.keepAlive = keepAlive;
    }

    public String getWill() {
        return will;
    }

    public void setWill(String will) {
        this.will = will;
    }

    public String getWillTopic() {
        return willTopic;
    }

    public void setWillTopic(String willTopic) {
        this.willTopic = willTopic;
    }

    public Integer getQos() {
        return qos;
    }

    public void setQos(Integer qos) {
        this.qos = qos;
    }

    public Boolean getIsDefault() {
        return isDefault;
    }

    public void setIsDefault(Boolean isDefault) {
        this.isDefault = isDefault;
    }

    public Boolean getIsRetain() {
        return isRetain;
    }

    public void setIsRetain(Boolean isRetain) {
        this.isRetain = isRetain;
    }

    public Boolean getIsSecureConnection() {
        return isSecureConnection;
    }

    public void setIsSecureConnection(Boolean isSecureConnection) {
        this.isSecureConnection = isSecureConnection;
    }

    public String getCertificatePath() {
        return certificatePath;
    }

    public void setCertificatePath(String certificatePath) {
        this.certificatePath = certificatePath;
    }

    public String getCertificatePassword() {
        return certificatePassword;
    }

    public void setCertificatePassword(String certificatePassword) {
        this.certificatePassword = certificatePassword;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<Topics> getTopics() {
        if (topics == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            TopicsDao targetDao = daoSession.getTopicsDao();
            List<Topics> topicsNew = targetDao._queryAccounts_Topics(id);
            synchronized (this) {
                if(topics == null) {
                    topics = topicsNew;
                }
            }
        }
        return topics;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetTopics() {
        topics = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<Messages> getMessageAccount() {
        if (messageAccount == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MessagesDao targetDao = daoSession.getMessagesDao();
            List<Messages> messageAccountNew = targetDao._queryAccounts_MessageAccount(id);
            synchronized (this) {
                if(messageAccount == null) {
                    messageAccount = messageAccountNew;
                }
            }
        }
        return messageAccount;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetMessageAccount() {
        messageAccount = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
